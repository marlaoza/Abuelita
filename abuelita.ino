#include <Adafruit_GFX.h>
#include <Adafruit_PCD8544.h>
#include <Adafruit_MPU6050.h>
#include <Adafruit_Sensor.h>
#include <SdFat.h>
#include <Wire.h>
#include <Keypad.h>
#include <math.h>


//modules declaration
#define RST_PIN   26
#define CE_PIN    15
#define DC_PIN    27
#define DIN_PIN   13
#define CLK_PIN   14
Adafruit_PCD8544 display = Adafruit_PCD8544(CLK_PIN, DIN_PIN, DC_PIN, CE_PIN, RST_PIN);

const byte ROWS = 4;
const byte COLS = 4;

char hexaKeys[ROWS][COLS] = {
  {'1','4','7','.'},
  {'2','5','8','0'},
  {'3','6','9','B'},
  {'H','M','Z','F'}
};
byte rowPins[ROWS] = {23, 19, 32, 33};
byte colPins[COLS] = {4, 18, 17, 16};
Keypad keypad = Keypad( makeKeymap(hexaKeys), rowPins, colPins, ROWS, COLS);

#define SD_MISO 12
#define SD_MOSI 13
#define SD_CLK  14
#define SD_CS   2

SdSpiConfig spiConfig(SD_CS, SHARED_SPI, SD_SCK_MHZ(16), &SPI);

//scl - 22
//sda - 21
Adafruit_MPU6050 mpu;

unsigned long currentTime = 0;

typedef struct activity {
  const char* name;
  void (*pSetup)();
  void (*pLoop)();
  const unsigned char* icon;
};

std::vector<activity> activities;
activity* curActivity;

void setActivity(int index) {
  display.clearDisplay();
  display.invertDisplay(false);
  resetKeyboardVariables();
  curActivity = &activities[index];
  Serial.println("SET ACTIVITY" + String(index));
  Serial.println(curActivity->name);
  curActivity->pSetup();
}

//keypad
const char t9Map[10][5] = {
  " ",
  ".,()",
  "abc",
  "def",
  "ghi",
  "jkl",
  "mno",
  "pqrs",
  "tuv",
  "wxyz",
};

unsigned long lastPressTime = 0;
char lastKey = '\0';
char key = '\0';
int charIndex = 0;
char curChar = '\0';
String inputText = "";
String sentText = "";
int maxDigits = -1;
int minDigits = 0;

uint8_t keyboardMode = 0;

void resetKeyboardVariables(){
  keyboardMode = 0;
  maxDigits = -1;
  minDigits = 0;
  inputText = "";
  sentText = "";
  curChar = '\0';
  charIndex = 0;
  key = '\0';
  lastKey = '\0';
}

void readKeyBoard(){
  key = keypad.getKey();
  if(key) {
    if(key == 'M'){
      Serial.println("ir pro menu");
      setActivity(0);
    }
    else if(key == 'H'){
      Serial.println("ir pra home");
      setActivity(1);
    }
  //modo texto
    if(keyboardMode == 1){

      if(key == 'B'){
        if(inputText.length() >= minDigits){
          sentText = inputText;
          inputText = "";
          lastPressTime = currentTime;
        }
      }
      else if(key == 'F'){
        if(inputText.length() > 0){
          inputText.remove(inputText.length() - 1);
        }
      }

      else if(key >= '0' && key <= '9' && (inputText.length() < maxDigits || maxDigits == -1)){
        int keyIndex = key - '0';
        int charCount = strlen(t9Map[keyIndex]);

        if(key == lastKey && ((currentTime - lastPressTime) < 1000)){
          charIndex = (charIndex + 1) % charCount;
        }else{
          charIndex=0;
          if(curChar != '\0'){
            inputText += curChar;
          }
          lastKey = key;
        }
        curChar = t9Map[keyIndex][charIndex];
        lastPressTime = currentTime;
      }
    }

  }

  if ((currentTime - lastPressTime) > 1000) {
    if(curChar != '\0'){
      inputText += curChar;
      curChar = '\0';
      lastKey = '\0';
      charIndex = 0;
    }
  }
}


//SD card
SdFat sd;
SdFile root;

void setupSD() {
  SPI.begin(SD_CLK, SD_MISO, SD_MOSI, SD_CS);
  
  if (!sd.begin(spiConfig)) {
    Serial.println("[SD] - ERROR");
    sd.initErrorHalt();
    while (true);
  }

  Serial.println("[SD] - OK");
  Serial.println("Files on card:");
  Serial.println("   Size    Name");

  sd.ls(LS_R | LS_SIZE);
}

//gyro
void setupGyro(){
  while (!mpu.begin()) {
    Serial.println("[GYRO] - ERROR");
    delay(1000);
  }
  Serial.println("[GYRO] - OK");
}

sensors_event_t event;

void readGyro(){
  mpu.getAccelerometerSensor()->getEvent(&event);
}

// i2s devices 
// speaker
// mic


// led
#define LED_R 23
#define LED_G 2
#define LED_B 12

void setupLed(){
  pinMode(LED_R, OUTPUT);
  pinMode(LED_G, OUTPUT);
  pinMode(LED_B, OUTPUT);
}
void setLed(uint8_t r, uint8_t g, uint8_t b){
  analogWrite(LED_R, r);
  analogWrite(LED_G, g);
  analogWrite(LED_B, b);
}

//rotary encoder
#define RE_CLK 25
#define RE_DT  5
#define RE_SW  0

#define DIRECTION_CW  0
#define DIRECTION_CCW 1

uint8_t direction = DIRECTION_CW;
uint8_t CLK_state;
uint8_t prev_CLK_state;
bool isButtonDown = false;
bool isRotating = false;

void setupRotaryEncoder(){
  pinMode(RE_CLK, INPUT);
  pinMode(RE_DT, INPUT);
  pinMode(RE_SW, INPUT_PULLUP);
  prev_CLK_state = digitalRead(RE_CLK);
  Serial.println("[ENCODER] - OK");
}

void readRotaryEncoder(){
  CLK_state = digitalRead(RE_CLK);

  if (CLK_state != prev_CLK_state && CLK_state == HIGH) {
    isRotating = true;
    if (digitalRead(RE_DT) == HIGH) {
      direction = DIRECTION_CCW;
    } else {
      direction = DIRECTION_CW;
    }

  }else{
    isRotating = false;
  }

  prev_CLK_state = CLK_state;
  isButtonDown = (digitalRead(RE_SW) == 0);

  
}

//display utils

void drawBitmapRotated(int16_t x, int16_t y,const uint8_t *bitmap,int w, int h, float angle) {
  float rad = (2*3.1415*angle)/360;

  int diag = sqrt(w*w + h*h);

  int sinA = (int)(sin(rad) * 256);
  int cosA = (int)(cos(rad) * 256);

  int cx_dst = diag / 2;
  int cy_dst = diag / 2;

  int cx_src = w / 2;
  int cy_src = h / 2;

  int bytesPerRow = (w + 7) / 8;

  for (int yy = 0; yy < diag; yy++) {
    for (int xx = 0; xx < diag; xx++) {

      int rx = (xx - cx_dst);
      int ry = (yy - cy_dst);

      int px = (int) (cx_src + ((rx * cosA + ry * sinA) >> 8));
      int py = (int) (cy_src + ((-rx * sinA + ry * cosA) >> 8));

      if (px < 0 || px >= w || py < 0 || py >= h)
        continue;

      int byteIndex = py * bytesPerRow + (px / 8);
      int bitIndex  = 7 - (px % 8);

      if (bitmap[byteIndex] & (1 << bitIndex)) {
        int sx = x + xx;
        int sy = y + yy;
        if (sx >= 0 && sx < 84 && sy >= 0 && sy < 48) {
          display.drawPixel(sx, sy, BLACK);
        }
      }


    }
  }
}

const unsigned char splash [] PROGMEM = {
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xbf, 0xff, 0xf0, 0xf7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x9f, 0xff, 
	0xf0, 0xf3, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x7f, 0xff, 0xf0, 0xcf, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0x7f, 0xff, 0xf0, 0xef, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xf0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0xff, 0xf8, 0xf0, 0xf2, 0x70, 0x73, 0xf0, 0xe0, 
	0x78, 0xff, 0xf0, 0xff, 0xf3, 0x67, 0x64, 0xa7, 0xa5, 0xe7, 0x4f, 0xb3, 0x7f, 0xf0, 0xff, 0xe4, 
	0xa4, 0xa4, 0xa4, 0x65, 0xf2, 0xe2, 0x64, 0xbf, 0xf0, 0xff, 0xe7, 0xa7, 0x64, 0xa7, 0x65, 0xf2, 
	0xf2, 0xe7, 0xbf, 0xf0, 0xff, 0xe4, 0xa4, 0xa4, 0xa4, 0x64, 0x72, 0xf2, 0xe4, 0xbf, 0xf0, 0xff, 
	0xe4, 0xa7, 0x73, 0x67, 0xa7, 0xa7, 0x72, 0xe4, 0xbf, 0xf0, 0xff, 0xf2, 0x70, 0xf8, 0xf0, 0x70, 
	0x70, 0xf9, 0xf2, 0x7f, 0xf0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0xff, 0xff, 0x1f, 0x9f, 0xff, 
	0xff, 0xfa, 0xf9, 0xfc, 0xff, 0xf0, 0xff, 0xff, 0x5f, 0xbf, 0xff, 0xff, 0xf8, 0xfd, 0xfa, 0xff, 
	0xf0, 0xff, 0xff, 0x1b, 0x3f, 0xff, 0xff, 0xfd, 0xf8, 0xd9, 0xff, 0xf0, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xf0, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x03, 0xff, 0xff, 0xff, 
	0xfe, 0xf0, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x00, 0xff, 0xff, 0xff, 0xfc, 0xf0, 0xff, 0xff, 0xff, 
	0xff, 0xf0, 0x03, 0xbf, 0xff, 0xff, 0xff, 0x30, 0xff, 0xff, 0xff, 0xff, 0xe1, 0xc5, 0x9f, 0xff, 
	0xff, 0xff, 0x70, 0xfe, 0xff, 0xff, 0xff, 0xc2, 0xe7, 0xef, 0xff, 0xff, 0xff, 0xf0, 0xfe, 0x7f, 
	0xff, 0xff, 0xc6, 0xe7, 0xf7, 0xff, 0xff, 0xff, 0xf0, 0xf9, 0xff, 0xff, 0xff, 0x87, 0x67, 0xf7, 
	0xff, 0xff, 0xff, 0xf0, 0xfd, 0xff, 0xff, 0xff, 0x83, 0xc3, 0xfb, 0xff, 0xff, 0xff, 0xf0, 0xff, 
	0xff, 0xff, 0xff, 0x80, 0x01, 0xfb, 0xff, 0xff, 0xff, 0xf0, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 
	0x77, 0xff, 0xff, 0xff, 0xf0, 0xff, 0xff, 0xff, 0xfe, 0x00, 0x00, 0xb7, 0xff, 0xff, 0xff, 0xf0, 
	0xff, 0xff, 0xff, 0x8e, 0x00, 0x01, 0xc7, 0xff, 0xff, 0xff, 0xf0, 0xff, 0xff, 0xfe, 0x03, 0x00, 
	0x01, 0xff, 0xff, 0xff, 0xff, 0xf0, 0xff, 0xff, 0xfc, 0x01, 0x60, 0x03, 0xff, 0xff, 0xff, 0xff, 
	0xf0, 0xff, 0xff, 0xf8, 0x01, 0x10, 0x07, 0xff, 0xff, 0xff, 0xff, 0xf0, 0xff, 0xff, 0xf8, 0x00, 
	0x8c, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xf0, 0xff, 0xff, 0xf0, 0x00, 0x83, 0xfd, 0xff, 0xfd, 0xff, 
	0xff, 0xf0, 0xff, 0xff, 0xe0, 0x00, 0x80, 0x04, 0x3f, 0xe1, 0xff, 0xff, 0xf0, 0xff, 0xff, 0xc0, 
	0x00, 0x80, 0x04, 0x00, 0x01, 0xff, 0xbf, 0xf0, 0xff, 0xff, 0x82, 0x20, 0xc0, 0x04, 0x00, 0x03, 
	0xff, 0x3f, 0xf0, 0xff, 0xfe, 0x06, 0x20, 0x40, 0x08, 0x00, 0x0f, 0xff, 0xcf, 0xf0, 0xff, 0xf0, 
	0x0c, 0x60, 0xc0, 0x08, 0x00, 0x0f, 0xff, 0xdf, 0xf0, 0xfe, 0x00, 0x30, 0x40, 0x80, 0x08, 0x40, 
	0x0f, 0xff, 0xff, 0xf0, 0xff, 0x70, 0xe0, 0x80, 0x80, 0x08, 0x38, 0x1f, 0xff, 0xff, 0xf0, 0xff, 
	0x9f, 0x03, 0x01, 0x80, 0x10, 0x0f, 0xff, 0xff, 0xff, 0xf0, 0xff, 0xc0, 0x0e, 0x01, 0x80, 0x10, 
	0x00, 0x7f, 0xff, 0xff, 0xf0, 0xff, 0x87, 0xf0, 0x07, 0xc0, 0x30, 0x01, 0xff, 0xff, 0xff, 0xf0
};

void setupDisplay(){
  display.begin();
  display.setContrast(90);
  display.clearDisplay();
  display.setTextSize(1);
  display.setTextColor(BLACK);
  display.setCursor(0, 0);
  Serial.println("[DISPLAY] - OK");
  display.drawBitmap(0, 0, splash, 84, 48, BLACK);
  display.display();
  delay(2000);
}

//TERMO
String wordBank[] PROGMEM = {
  "termo","teste","carta","linda","festa",
  "amigo","vento","praia","sabor","ponto",
  "linha","porta","livro","canto","chave",
  "olhar","dente","viver","corpo","sinto",
  "noite","claro","sinal","fruta","pilar",
  "cobre","mundo","verde","tente","falar",
  "mesmo","igual","jovem","grato","cegar",
  "amado","justo","risos","pedra","lugar",
  "campo","firme","rival","tocar","dorso",
  "vazio","pegar","louco","queda","brisa",
  "raiva","velho","vigor","ciclo","ideia",
  "plano","humor","afeto","barco","fecho",
  "obvio","sorte","clima","sonho","piano",
  "trono","coisa","amiga","couro","astro",
  "frase","venda","trigo","leite","sutil",
  "levar","norte","chuva","bravo","digno",
  "pular","selva","quiet","criar","amplo",
  "faixa","doido","tarde","fugir","muito",
  "gente","perto","bater","lutar","honra",
  "nuvem","magia","grato","sabor","senso",
  "carga","linha","tempo","linda","risco"
};

const unsigned char ico_termo [] PROGMEM = {
	0x00, 0x00, 0x00, 0xff, 0xff, 0xc0, 0xff, 0xff, 0xc0, 0x00, 0x00, 0x00, 0xf3, 0xe3, 0xc0, 0x12, 
	0x22, 0x00, 0xb2, 0xa2, 0x80, 0xbe, 0x7e, 0x80, 0xa2, 0xaa, 0x80, 0xae, 0xa2, 0x00, 0xe3, 0xeb, 
	0xc0, 0x2e, 0x2a, 0x00, 0x22, 0x2a, 0x00, 0x3e, 0x3e, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xc0, 
	0xff, 0xff, 0xc0, 0x00, 0x00, 0x00};

const unsigned char termo_end [] PROGMEM = {
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xf0, 0xff, 0xfc, 0xf1, 0xcd, 0xf3, 0x74, 0x73, 0xc2, 0x39, 0xff, 0xf0, 0xff, 0xfb, 0x76, 0xb5, 
	0xed, 0x75, 0xad, 0xde, 0xd6, 0xff, 0xf0, 0xff, 0xf8, 0x71, 0x85, 0xe1, 0xac, 0x61, 0xc6, 0x30, 
	0xff, 0xf0, 0xff, 0xfb, 0x77, 0xb5, 0xed, 0xad, 0x6d, 0xde, 0xb6, 0xff, 0xf0, 0xff, 0xfb, 0x77, 
	0xb4, 0x2d, 0xdd, 0xad, 0xc2, 0xd6, 0xff, 0xf0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xf0, 0xff, 0xff, 0xff, 0x80, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xf0, 0xff, 0xff, 
	0xff, 0x80, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xf0, 0xff, 0xff, 0xff, 0x80, 0x00, 0x00, 0x00, 
	0xff, 0xff, 0xff, 0xf0, 0xff, 0xff, 0xff, 0x80, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xf0, 0xff, 
	0xff, 0xff, 0x80, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xf0, 0xff, 0xff, 0xff, 0x80, 0x00, 0x00, 
	0x00, 0xff, 0xff, 0xff, 0xf0, 0xff, 0xff, 0xff, 0x80, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xf0, 
	0xff, 0xff, 0xff, 0x80, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xf0, 0xff, 0xff, 0xff, 0x80, 0x00, 
	0x00, 0x00, 0xff, 0xff, 0xff, 0xf0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xf0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0xff, 0xfc, 0xe6, 0xd8, 0x86, 0x6d, 0x16, 0xe1, 0x77, 
	0xff, 0xf0, 0xff, 0xfb, 0x5a, 0x57, 0xbd, 0xed, 0xb6, 0xef, 0x27, 0xff, 0xf0, 0xff, 0xfb, 0xda, 
	0x99, 0x8d, 0x2d, 0xb6, 0xe3, 0x57, 0xff, 0xf0, 0xff, 0xfb, 0x5a, 0xde, 0xbd, 0xad, 0xb6, 0xef, 
	0x77, 0xff, 0xf0, 0xff, 0xfc, 0xe6, 0xd1, 0x86, 0x73, 0x19, 0xe1, 0x77, 0xff, 0xf0, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0xff, 0xf0, 0x3f, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xf0, 0xff, 0xf0, 0x20, 0x85, 0xa0, 0xcc, 0x11, 0x76, 0x71, 0xff, 0xf0, 0xff, 
	0xf0, 0x3b, 0xbc, 0xbb, 0xb7, 0x7b, 0x75, 0xaf, 0xff, 0xf0, 0xff, 0xf0, 0x3b, 0x8d, 0x3b, 0x87, 
	0x7b, 0xac, 0x33, 0xff, 0xf0, 0xff, 0xf0, 0x3b, 0xbd, 0xbb, 0xb7, 0x7b, 0xad, 0xbd, 0xff, 0xf0, 
	0xff, 0xf0, 0x3b, 0x85, 0xbb, 0xb7, 0x71, 0xdd, 0xa3, 0xff, 0xf0, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xf0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xf0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0xff, 0xe7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xf0, 0xe3, 0xdd, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0xef, 0xd9, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0xe2, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xf0, 0xfb, 0xcd, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0xe3, 
	0xdd, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0xff, 0xf3, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xf0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0
};

String targetWord = "";
int curTermoRow = 0;
int termoXOffset = 17;
int termoYOffset= 2;

bool termoWon = false;
bool playingTermo;

String targetWordCopy = "";

void drawTermoRow(String word, int row){
  targetWordCopy = targetWord;
  int amtRight = 0;
  int Ypos = (row*9) + termoYOffset;

  for (int col = 0; col < 5; col++){
    int Xpos = (col*11) + termoXOffset;
    if(word[col] != ' '){
      bool allRight = (word[col] == targetWordCopy[col]);
      if(allRight){
        display.fillRect(Xpos, Ypos, 9, 8, BLACK);
        display.setTextColor(WHITE);
        display.setCursor(Xpos+2, Ypos);
        display.print(word[col]);
        word[col] = ' ';
        targetWordCopy[col] = ' ';
        amtRight++;
      }
    }
  }

  targetWordCopy = targetWord;

  for (int col = 0; col < 5; col ++){
    if(word[col] != ' '){
      int Xpos = (col*11) + termoXOffset;
      int index = targetWordCopy.indexOf(word[col]);
      bool letterRight = index != -1;
      if(letterRight){
          targetWordCopy[index] = ' ';
          display.drawRect(Xpos, Ypos, 9, 8, BLACK);
      }
      else{
        display.fillRect(Xpos, Ypos, 9, 8, WHITE);
      }
      display.setTextColor(BLACK);
      display.setCursor(Xpos+2, Ypos);
      display.print(word[col]);
    }
  }

  display.display();
  if(amtRight == 5){
    termoWon = true;
  }
}

void drawTermoMap() {
  for (int row = 0; row < 5; row++){
    for (int col = 0; col<5; col++){
      int Xpos = (col*11) + termoXOffset;
      int Ypos = (row*9) + termoYOffset;
      display.drawRect(Xpos, Ypos, 9, 8, BLACK);
    }
  }
  display.display();
}

void drawTermoEndScreen(){
  display.setTextColor(BLACK);
  display.clearDisplay();
  display.drawBitmap(0, 0, termo_end, 84, 48, BLACK);
  display.setCursor(26, 10);
  display.print(targetWord);

  if(termoWon){
    display.setCursor(13,28);
    display.print(String(curTermoRow));
  }else{
    display.fillRect(11,20, 62, 16, BLACK);
  }
  display.display();
}

void setupTermo(){

  targetWord = wordBank[random(0, sizeof(wordBank) / sizeof(wordBank[0]) - 1 )];

  curTermoRow = 0;
  maxDigits = 5;
  minDigits = 5;
  keyboardMode = 1;

  display.clearDisplay();
  display.setTextSize(1);
  drawTermoMap();

  playingTermo = true;
  termoWon = false;
  inputText = "";
  curChar = '\0';
}

void loopTermo(){
  if(playingTermo){
    if(sentText != ""){
      drawTermoRow(sentText, curTermoRow);
      curTermoRow++;
      sentText = "";
    }
  
    else{
      String inputingText = inputText + curChar;
      int Ypos = (curTermoRow*9) + termoYOffset;
      for (int col = 0; col < 5; col++){
        int Xpos = (col*11) + termoXOffset;
        display.fillRect(Xpos+1, Ypos+1, 7, 6, WHITE);
        display.setCursor(Xpos+2, Ypos);
        display.print(inputingText[col]);
      }
      display.display();
    }

    if(curTermoRow == 5 || termoWon){
      playingTermo = false;
      drawTermoEndScreen();
    }


  }else{
    if(key){
      setupTermo();
    }
  }
}


//NOTAS
typedef struct nota {
  String name;
  String text;
};

std::vector<nota> notas;

nota* openNota;

bool notasMenu = true;

const unsigned char ico_notas [] PROGMEM = {
	0xff, 0xff, 0xc0, 0x80, 0x00, 0x40, 0xb8, 0x00, 0x40, 0x80, 0x00, 0x40, 0xaf, 0xff, 0x40, 0xa9, 
	0x01, 0x40, 0xaf, 0xff, 0x40, 0xac, 0x05, 0x40, 0xaf, 0xff, 0x40, 0xa8, 0x21, 0x40, 0xaf, 0xff, 
	0x40, 0xa8, 0x41, 0x40, 0xaf, 0xff, 0x40, 0xaf, 0x01, 0x40, 0xaf, 0xff, 0x40, 0xaf, 0xff, 0x40, 
	0x80, 0x00, 0x40, 0xff, 0xff, 0xc0};

int fixedOffset = 0;
void drawNota(){
  display.clearDisplay();
  String txt = openNota->text + inputText + curChar;
  int offset = (txt.length() - 56);
  offset = offset < 0 ? 0 : ceil((offset + 0.5) / 14);

  display.setTextColor(BLACK);
  display.setCursor(0, 13 - ((offset * 7) + fixedOffset));
  display.print(txt);

  display.fillRect(0, 0, 84, 9, BLACK);

  display.drawFastHLine(0, 10, 84, WHITE);
  display.drawFastHLine(0, 11, 84, BLACK);
  display.drawFastHLine(0, 47, 84, BLACK);

  display.setTextSize(1);
  display.setTextColor(WHITE);
  display.setCursor(1, 1);
  display.print(openNota->name);

  
  display.display();
}
int hoveredNota = 0;
#define NOTAS_PER_ROW 2
int selectedNota = 0;

const unsigned char notas_bg [] PROGMEM = {
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x00, 0x03, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x01, 0xff, 
	0xf0, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x3a, 0x4c, 0x89, 0x80, 0x00, 0x10, 0xc0, 0x00, 0x00, 0x00, 
	0x00, 0x3b, 0x52, 0x8a, 0x40, 0x00, 0x10, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x3a, 0xd2, 0x53, 0xc0, 
	0x00, 0x10, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x3a, 0x52, 0x52, 0x40, 0x00, 0x10, 0xc0, 0x00, 0x00, 
	0x00, 0x00, 0x3a, 0x4c, 0x22, 0x40, 0x00, 0x10, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 
	0x00, 0x00, 0x10, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x38, 0x00, 0x24, 0xcf, 0x98, 0x10, 0xc0, 0x00, 
	0x00, 0x00, 0x00, 0x38, 0x00, 0x35, 0x22, 0x24, 0x10, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x38, 0x00, 
	0x2d, 0x22, 0x3c, 0x10, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x38, 0x00, 0x25, 0x22, 0x24, 0x10, 0xc0, 
	0x00, 0x00, 0x00, 0x00, 0x38, 0x00, 0x24, 0xc2, 0x24, 0x10, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x38, 
	0x00, 0x00, 0x00, 0x00, 0x10, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x00, 0x00, 0x10, 
	0xc0, 0x00, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x00, 0x00, 0x10, 0xc0, 0x00, 0x00, 0x00, 0x00, 
	0x38, 0x00, 0x00, 0x00, 0x00, 0x10, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x00, 0x00, 
	0x10, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x00, 0x00, 0x10, 0xc0, 0x00, 0x00, 0x00, 
	0x00, 0x38, 0x00, 0x00, 0x00, 0x00, 0x10, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x00, 
	0x00, 0x10, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x00, 0x00, 0x10, 0xc0, 0x00, 0x00, 
	0x00, 0x00, 0x38, 0x00, 0x00, 0x00, 0x00, 0x10, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 
	0x00, 0x00, 0x10, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x00, 0x00, 0x10, 0xc0, 0x00, 
	0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x00, 0x00, 0x10, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x38, 0x00, 
	0x00, 0x00, 0x00, 0x10, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x00, 0x00, 0x10, 0xc0, 
	0x00, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x00, 0x00, 0x10, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x38, 
	0x00, 0x00, 0x00, 0x00, 0x10, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x00, 0x00, 0x10, 
	0xc0, 0x00, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x00, 0x00, 0x10, 0xc0, 0x00, 0x00, 0x00, 0x00, 
	0x38, 0x00, 0x00, 0x00, 0x00, 0x10, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x00, 0x00, 
	0x10, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x38, 0x07, 0xff, 0xff, 0xf0, 0x10, 0xc0, 0x00, 0x00, 0x00, 
	0x00, 0x38, 0x0c, 0xc6, 0x33, 0x18, 0x10, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x38, 0x0b, 0x5b, 0x6d, 
	0x68, 0x10, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x38, 0x0b, 0xc7, 0x61, 0x18, 0x10, 0xc0, 0x00, 0x00, 
	0x00, 0x00, 0x38, 0x0b, 0x57, 0x6d, 0x58, 0x10, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x38, 0x0c, 0xda, 
	0x2d, 0x68, 0x10, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x38, 0x07, 0xff, 0xff, 0xf0, 0x10, 0xc0, 0x00, 
	0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x00, 0x00, 0x10, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x38, 0x00, 
	0x00, 0x00, 0x00, 0x10, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x00, 0x00, 0x10, 0xc0, 
	0x00, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x01, 0xff, 0xe0, 0xc0, 0x00, 0x00, 0x00, 0x03, 0xff, 
	0xff, 0xff, 0xfe, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00
};

bool newNota = false;
int hoverNewNotaItem = 0;
bool onInput = false;
String notaName = "";

void drawNotasMenu(){
  display.clearDisplay();
  display.drawBitmap(0,0,notas_bg,84,48,BLACK);
  int xOffset = 3;
  int yOffset = 3;
  int Xpos = 0;
  int Ypos = 0;
  int index = 0;

  int width = 38;
  int height = 11;

  //yOffset -= hoveredNota * 18;
  
  if((hoveredNota*(height+1)) + yOffset + height > 44) {
    Serial.println("fora");
    yOffset -= (((hoveredNota*(height+1)) + yOffset + height) - 44);
  }

  for (int i = 0; i < notas.size(); i++){
    Xpos = xOffset;
    Ypos = (i*(height+1)) + yOffset;
    display.setTextColor(BLACK);
    display.drawRect(Xpos, Ypos, width, height, BLACK);

    if(hoveredNota == i){
      display.setTextColor(WHITE);
      display.fillRect(Xpos, Ypos, width, height, BLACK);
    }

    display.setCursor(Xpos+2, Ypos+2);
    display.print(notas[i].name);
  }

  display.setTextColor(BLACK);

  if(newNota && hoverNewNotaItem == 0){
    display.drawFastHLine(46, 28, 35, BLACK);
  }

  display.setCursor(46, 20);
  display.print(notaName);
  
  if(newNota && hoverNewNotaItem == 1){
    display.drawRect(51, 34, 27, 9, BLACK);
  }

  display.display();
}

void selectNota(int index){
  openNota = &notas[index];
  notasMenu = false;
  inputText = "";
  sentText = "";
  curChar = '\0';
  charIndex = 0;
  key = '\0';
  lastKey = '\0';
  drawNota();
}

void setupNotas(){
  display.clearDisplay();
  notas.push_back({ "nota0", "" });
  notas.push_back({ "nota1", "" });
  notas.push_back({ "nota2", "" });
  notas.push_back({ "nota3", "" });
  notas.push_back({ "nota4", "" });
  notas.push_back({ "nota5", "" });
  notas.push_back({ "nota6", "" });
  notas.push_back({ "nota7", "" });
  notas.push_back({ "nota8", "" });
  notas.push_back({ "nota9", "" });
  notas.push_back({ "nota10", "" });
  keyboardMode = 1;
  maxDigits = -1;
  notasMenu = true;
  drawNotasMenu();

}

int lastHoveredNota = 0;
void loopNotas(){
    if(notasMenu){
      if(key){
        if(onInput && newNota){
          notaName = inputText + curChar;
          if(key == 'B'){
            onInput = false;
            keyboardMode = 0;
            maxDigits = -1;
            notaName = sentText + curChar;
            sentText = "";
            
          }
        }else{
          switch(key){
            case '2':
              if(!newNota){if(hoveredNota >= 1) hoveredNota -= 1;}
              else{hoverNewNotaItem = hoverNewNotaItem == 1 ? 0 : 1;}
              break;
            case '8':
              if(!newNota){if(hoveredNota < (notas.size()) - 1){ hoveredNota += 1;}}
              else{hoverNewNotaItem = hoverNewNotaItem == 0 ? 1 : 0;}
              break;
            case '6':
              if(!newNota){newNota = true; lastHoveredNota = hoveredNota; hoveredNota = -1;}
              break;
            case '4':
              if(newNota){newNota = false; hoveredNota = lastHoveredNota;}
              break;
            case '5':
              if(!newNota){selectNota(hoveredNota);}
              if(newNota){
                if(hoverNewNotaItem == 1){
                  notas.push_back({notaName, "" });
                  selectNota(notas.size()-1);
                }else if(hoverNewNotaItem == 0){
                  if(!onInput){
                    inputText = "";
                    sentText = "";
                    curChar = '\0';
                    onInput = true;
                    keyboardMode = 1;
                    maxDigits = 5;
                  };
                }
              }
              break;
          }
        }
        drawNotasMenu();
      }
    }else{
      if(key == 'F'){
        if(inputText.length() <= 0){
          if(openNota->text.length() > 0){
            openNota->text.remove(openNota->text.length() - 1);
          }
        }
      }
      if(key == 'B'){
        openNota->text += (sentText + "\n");
        sentText = "";
      }
      if(key == 'Z'){
        //save nota
        notasMenu = true;
        drawNotasMenu();
        return;
      }

      if(isRotating){
        if(direction == DIRECTION_CW){
          fixedOffset += 1;
        }else{
          fixedOffset -= 1;
        }
      }
      
      drawNota();
    }
}


//HOME
// 'eye_r', 23x18px
const unsigned char eye_r [] PROGMEM = {
	0x03, 0xff, 0x80, 0x0f, 0xff, 0xe0, 0x1f, 0xff, 0xf0, 0x38, 0x03, 0xf8, 0x70, 0x01, 0xfc, 0xe0, 
	0x01, 0xfe, 0xe0, 0x00, 0xfe, 0xc0, 0x00, 0xfe, 0xc0, 0x00, 0xe6, 0xc0, 0x00, 0xe0, 0xc0, 0x01, 
	0xc0, 0xc0, 0x01, 0xc0, 0xc0, 0x03, 0x80, 0xe0, 0x07, 0x80, 0xf0, 0x0f, 0x00, 0x3f, 0xfe, 0x00, 
	0x1f, 0xfc, 0x00, 0x07, 0xe0, 0x00
};
// 'pupil_r', 10x10px
const unsigned char pupil_r [] PROGMEM = {
	0x3f, 0x00, 0x67, 0x80, 0xcf, 0xc0, 0xff, 0xc0, 0xff, 0xc0, 0xff, 0xc0, 0xff, 0xc0, 0xdf, 0x80, 
	0x7f, 0x00, 0x1e, 0x00
};

// 'eye_l', 23x18px
const unsigned char eye_l [] PROGMEM = {
	0x03, 0xff, 0x80, 0x0f, 0xff, 0xe0, 0x1f, 0xff, 0xf0, 0x3f, 0x80, 0x38, 0x7f, 0x00, 0x1c, 0xff, 
	0x00, 0x0e, 0xfe, 0x00, 0x0e, 0xfe, 0x00, 0x06, 0xce, 0x00, 0x06, 0x0e, 0x00, 0x06, 0x07, 0x00, 
	0x06, 0x07, 0x00, 0x06, 0x03, 0x80, 0x06, 0x03, 0xc0, 0x0e, 0x01, 0xe0, 0x1e, 0x00, 0xff, 0xf8, 
	0x00, 0x7f, 0xf0, 0x00, 0x0f, 0xc0
};
// 'pupil_l', 10x10px
const unsigned char pupil_l [] PROGMEM = {
	0x3f, 0x00, 0x67, 0x80, 0xcf, 0xc0, 0xff, 0xc0, 0xff, 0xc0, 0xff, 0xc0, 0xff, 0xc0, 0x6f, 0xc0, 
	0x3f, 0x80, 0x1f, 0x00
};

// 'face', 84x48px
const unsigned char face [] PROGMEM = {
	0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x80, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 
	0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x80, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x01, 0xe0, 0x00, 0x00, 0x00, 0x78, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xf8, 0x00, 0x00, 
	0x01, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xfe, 0x00, 0x00, 0x07, 0xf8, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x01, 0xff, 0x80, 0xf0, 0x1f, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 0xe7, 
	0xfe, 0x7f, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xff, 0xff, 0xff, 0xc0, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 
	0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xff, 0xff, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x1e, 0x7f, 0xff, 0xe7, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x1c, 0x7e, 0x07, 0xe3, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1e, 0xf0, 0x00, 0xf7, 0x80, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xe0, 0x00, 0x7f, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x1f, 0x80, 0x00, 0x1f, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x00, 0x00, 0x0f, 
	0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x0f, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 
	0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x80, 
	0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xc0, 0x00, 0x0e, 0x00, 0x00, 0x00, 
	0x00, 0x80, 0x00, 0x00, 0x03, 0xc0, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x10, 0x80, 0x00, 0x00, 0x03, 
	0xe0, 0x00, 0x1c, 0x00, 0x00, 0x00, 0x10, 0x80, 0x00, 0x00, 0x01, 0xf0, 0x00, 0x38, 0x00, 0x00, 
	0x00, 0x10, 0xc0, 0x00, 0x00, 0x00, 0xf8, 0x00, 0x70, 0x00, 0x00, 0x00, 0x30, 0xc0, 0x00, 0x00, 
	0x00, 0x7c, 0x00, 0xe0, 0x00, 0x00, 0x00, 0x30, 0xe0, 0x00, 0x00, 0x00, 0x3c, 0x00, 0xc0, 0x00, 
	0x00, 0x00, 0x70, 0xf0, 0x00, 0x00, 0x00, 0x1e, 0x01, 0x80, 0x00, 0x00, 0x00, 0xf0, 0xf8, 0x00, 
	0x00, 0x00, 0x1f, 0x03, 0x80, 0x00, 0x00, 0x01, 0xf0, 0xfc, 0x00, 0x00, 0x00, 0x0f, 0x87, 0x00, 
	0x00, 0x00, 0x03, 0xf0, 0xfe, 0x00, 0x00, 0x00, 0x07, 0x8e, 0x00, 0x00, 0x00, 0x07, 0xf0, 0xff, 
	0x80, 0x00, 0x00, 0x03, 0xdc, 0x00, 0x00, 0x00, 0x1f, 0xf0, 0xff, 0xe0, 0x00, 0x00, 0x01, 0xf8, 
	0x00, 0x00, 0x00, 0x7f, 0xf0, 0xff, 0xff, 0x80, 0x00, 0x00, 0xf0, 0x00, 0x00, 0x1f, 0xff, 0xf0
};

struct Pupil {
  int x; //  1 -> 9 {+63}
  int y; // 5 -> 14
  //int rotation; //0 - 3 = 0, 90, 180, 270
};
struct Eye {
  int state;
  Pupil pupil;
};


Eye leftEye = {0, {9, 8}};
Eye rightEye = {0, {65, 8}};

const unsigned char ico_home [] PROGMEM = {
	0x7f, 0xff, 0x80, 0xff, 0xff, 0xc0, 0xff, 0xff, 0xc0, 0xff, 0xff, 0xc0, 0x7f, 0xff, 0x80, 0x07, 
	0xf8, 0x00, 0xc3, 0xf2, 0x40, 0x8c, 0x0c, 0x40, 0x88, 0x04, 0x40, 0xf9, 0xe7, 0xc0, 0xfb, 0xf7, 
	0xc0, 0xfd, 0xef, 0xc0, 0xfd, 0xef, 0xc0, 0xfe, 0xdf, 0xc0, 0xff, 0x3f, 0xc0, 0x7f, 0xff, 0x80, 
	0x3f, 0xff, 0x00, 0x1f, 0xfe, 0x00 };

void drawEyes(){
  display.fillRect(0, 4, 23, 18, WHITE);
  display.drawBitmap(leftEye.pupil.x, leftEye.pupil.y, pupil_l, 10, 10, BLACK);
  display.drawBitmap(0, 4, eye_l, 23, 18, BLACK);

  display.fillRect(61, 4, 23, 18, WHITE);
  display.drawBitmap(rightEye.pupil.x, rightEye.pupil.y, pupil_r, 10, 10, BLACK);
  display.drawBitmap(61, 4, eye_r, 23, 18, BLACK);

}
void setupHome(){
  display.clearDisplay();
  
  display.drawBitmap(0, 0, face, 84, 48, BLACK);
  drawEyes();
  display.display();
}
void loopHome(){
}

//MENU
#define APPS_PER_ROW 3

uint8_t selectedApp = 1;
uint8_t curPage = 0;

void drawMenu(){
  display.clearDisplay();
  int xOffset = 10;
  int yOffset = 3;
  int Xpos = 0;
  int Ypos = 0;
  int index = 0;

  if((floor((selectedApp-1)/APPS_PER_ROW)*24) + yOffset < 48){
    Serial.println("fora");
  }

  for (int i = 1; i < activities.size(); i++){
    Xpos = (((i-1) % APPS_PER_ROW)*23) + xOffset;
    Ypos = (floor((i-1)/APPS_PER_ROW)*24) + yOffset;
    display.drawRect(Xpos, Ypos, 20, 20, BLACK);
    display.drawBitmap(Xpos+1, Ypos+1, activities[i].icon, 18, 18, BLACK);

    if(selectedApp == i){
      display.drawRect(Xpos-1, Ypos-1, 22, 22, BLACK);
    }
  }

  display.display();

}
void setupMenu(){
  selectedApp = 0;
  drawMenu();
}
void loopMenu(){
  if(key){
    switch(key){
      case '2':
        if(selectedApp >= APPS_PER_ROW) selectedApp -= APPS_PER_ROW;
        break;
      case '8':
        if(selectedApp + APPS_PER_ROW <= activities.size() - 1) selectedApp += APPS_PER_ROW;
        break;
      case '4':
        if(selectedApp > 1) selectedApp -= 1;
        break;
      case '6':
        if(selectedApp < activities.size()-1) selectedApp += 1;
        break;
      case '5':
        setActivity(selectedApp);
        return;
    }
    drawMenu();
  }
}

void setup()   {
  Serial.begin(115200);

  
  activities.push_back({ "MENU", setupMenu, loopMenu, nullptr});

  activities.push_back({ "HOME", setupHome, loopHome, ico_home});
  activities.push_back({ "NOTAS", setupNotas, loopNotas, ico_notas});
  activities.push_back({ "TERMO", setupTermo, loopTermo, ico_termo});

  Serial.println("Setting up peripherals");

  // setupLed();
  //setupGyro();
  setupRotaryEncoder();
  //setupSD();
  setupDisplay();
  Serial.println("Finished setting up peripherals");
  setActivity(0);
}

void loop(){
  currentTime = millis();
  readKeyBoard();
  readRotaryEncoder();
  // //readGyro();
  if(curActivity) curActivity->pLoop();
}
